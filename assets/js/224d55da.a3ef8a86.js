"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1504],{6103:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>m,frontMatter:()=>c,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"examples/core-components/point-attractor","title":"Point Attractors","description":"This page shows how Dynamical Systems (DS), and in particular Point Attractor components, can be used to generate","source":"@site/core/examples/core-components/point-attractor.md","sourceDirName":"examples/core-components","slug":"/examples/core-components/point-attractor","permalink":"/core/examples/core-components/point-attractor","draft":false,"unlisted":false,"editUrl":"https://github.com/aica-technology/api/tree/main/core/core/examples/core-components/point-attractor.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Point Attractors"},"sidebar":"studioSidebar","previous":{"title":"Colliders","permalink":"/core/examples/core-components/colliders"},"next":{"title":"Core Controllers","permalink":"/core/category/core-controllers"}}');var o=n(4848),r=n(8453);const i=n.p+"assets/images/point-attractor-acd377f058345ec2acf48c8d93de1e1e.png",s=n.p+"assets/medias/point-attractor-example-d7f08bfe8bef942d9c0c54aff4a08b41.webm",c={sidebar_position:3,title:"Point Attractors"},l="Point Attractors",d={},h=[{value:"Signal Point Attractor (Cartesian space)",id:"signal-point-attractor-cartesian-space",level:2},{value:"Interfaces",id:"interfaces",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Example",id:"example",level:2}];function p(e){const t={a:"a",admonition:"admonition",annotation:"annotation",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",math:"math",mi:"mi",mrow:"mrow",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,r.R)(),...e.components},{Details:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"point-attractors",children:"Point Attractors"})}),"\n",(0,o.jsx)(t.p,{children:"This page shows how Dynamical Systems (DS), and in particular Point Attractor components, can be used to generate\ndynamic motions in AICA Studio. Point Attractor DS are valuable in robotics because they provide a simple and robust way\nto guide a robot toward a specific target. By continuously generating motion commands that drive to the attractor, these\ncomponents enable reaching, positioning, and interaction tasks, making them useful for applications such as\npick-and-place, assembly, and human-robot collaboration."}),"\n",(0,o.jsxs)(t.p,{children:["As described ",(0,o.jsx)(t.a,{href:"/docs/concepts/robotics-concepts/motion-generation",children:"here"}),", the motion of a Point Attractor DS is always\ndirected toward a point in space, the attractor. The core components come with two implementations of a Point Attractor,\nthe ",(0,o.jsx)(t.code,{children:"Signal Point Attractor"})," which acts on signals in Cartesian space and the ",(0,o.jsx)(t.code,{children:"Signal Joint Point Attractor"})," which has\nthe same behavior in joint space."]}),"\n",(0,o.jsx)(t.h2,{id:"signal-point-attractor-cartesian-space",children:"Signal Point Attractor (Cartesian space)"}),"\n",(0,o.jsx)(t.h3,{id:"interfaces",children:"Interfaces"}),"\n",(0,o.jsxs)(t.p,{children:["The component has three inputs and one output, all of type ",(0,o.jsx)(t.code,{children:"cartesian_state"}),":"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Input pose: The current state of the DS, e.g. the pose used to calculate the motion towards the attractor."}),"\n",(0,o.jsx)(t.li,{children:"Attractor pose: The attractor of the DS, e.g. the pose towards which the motion guides the robot."}),"\n",(0,o.jsx)(t.li,{children:"Base frame: This input is reserved to advanced users and can be used in cases where the DS should be expressed in a\nmoving reference frame."}),"\n",(0,o.jsx)(t.li,{children:"Output twist: The linear and angular velocity generated by the DS to drive the input towards the attractor."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Usually, the goal of a Point Attractor is to move a robot to a desired point in space. The predicates of the component\nhelp to detect when that is achieved such that other events can be triggered:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Is in linear range: This predicate is true whenever the linear distance between input and attractor is below a\nconfigurable threshold (see parameters section below)."}),"\n",(0,o.jsx)(t.li,{children:"Is in angular range: This predicate is true whenever the angular distance between input and attractor is below a\nconfigurable threshold (see parameters section below)."}),"\n",(0,o.jsx)(t.li,{children:"Is in range: This predicate is true whenever the linear and angular range predicates are both true."}),"\n"]}),"\n",(0,o.jsx)("div",{class:"text--center",children:(0,o.jsx)("img",{src:i,alt:"Point Attractor interfaces"})}),"\n",(0,o.jsx)(t.h3,{id:"parameters",children:"Parameters"}),"\n",(0,o.jsx)(t.p,{children:"Changing the parameters of the component will tune the response and decide at which threshold the predicates switch:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["Linear and angular gains: As shown\n",(0,o.jsx)(t.a,{href:"/docs/concepts/robotics-concepts/motion-generation#point-attractor-dynamical-system",children:"here"}),", the function of the DS\ncontains an additional scaling constant ",(0,o.jsxs)(t.span,{className:"katex",children:[(0,o.jsx)(t.span,{className:"katex-mathml",children:(0,o.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,o.jsxs)(t.semantics,{children:[(0,o.jsx)(t.mrow,{children:(0,o.jsx)(t.mi,{children:"K"})}),(0,o.jsx)(t.annotation,{encoding:"application/x-tex",children:"K"})]})})}),(0,o.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,o.jsxs)(t.span,{className:"base",children:[(0,o.jsx)(t.span,{className:"strut",style:{height:"0.6833em"}}),(0,o.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"K"})]})})]}),", represented by the linear and angular gains parameters here. The higher\nthese values are, the higher the generated velocity. Both parameters are of type vector, so it is also possible to set\ndifferent gains per axis, or even disabling motion along some axis entirely.","\n",(0,o.jsx)(t.admonition,{type:"warning",children:(0,o.jsx)(t.p,{children:"Setting high gains can lead to fast movements and overshoot."})}),"\n"]}),"\n",(0,o.jsx)(t.li,{children:"Maximal linear and angular velocity: Before publishing the output twist, the component clamps the linear and angular\nvelocities to the values of those two parameters. This allows to increase the gains without generating an excessive\nresponse."}),"\n",(0,o.jsx)(t.li,{children:"Linear and angular precision threshold: The linear and angular distances from the attractor for the input to qualify\nas in linear and angular range (see predicates above)."}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,o.jsx)(t.p,{children:"To set up this example, follow the steps below."}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["Create a new application and record the tool frame of the robot of your choice as described\n",(0,o.jsx)(t.a,{href:"../guides/application-frames#record-a-frame",children:"here"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["In the same application, add the ",(0,o.jsx)(t.code,{children:"Frame to Signal"})," component. Click on auto-configure and auto-activate buttons to enable\nthem and in the component settings, set the required parameter ",(0,o.jsx)(t.code,{children:"Frame"})," to the name of the recorded frame from step 1.","\n",(0,o.jsx)(t.admonition,{type:"tip",children:(0,o.jsxs)(t.p,{children:["Learn more about the ",(0,o.jsx)(t.code,{children:"Frame to Signal"})," component ",(0,o.jsx)(t.a,{href:"/docs/concepts/building-blocks/frames#frame-to-signal",children:"here"}),"."]})}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["Add the ",(0,o.jsx)(t.code,{children:"Signal Point Attractor"})," to the graph and enable auto-configure and auto-activate. Then, connect the ",(0,o.jsx)(t.code,{children:"Pose"}),"\noutput of the component from step 2 with the ",(0,o.jsx)(t.code,{children:"Attractor pose"})," input. Also connect the ",(0,o.jsx)(t.code,{children:"Cartesian state"})," output of the\n",(0,o.jsx)(t.code,{children:"Robot State Broadcaster"})," in the hardware with the ",(0,o.jsx)(t.code,{children:"Input pose"})," input."]}),"\n",(0,o.jsxs)(t.li,{children:["Add the ",(0,o.jsx)(t.code,{children:"IK Velocity Controller"})," to the hardware, enable auto-load and auto-activate, and connect the ",(0,o.jsx)(t.code,{children:"Output twist"}),"\nof the ",(0,o.jsx)(t.code,{children:"Point Attractor"})," with the ",(0,o.jsx)(t.code,{children:"Command"})," input of the controller."]}),"\n",(0,o.jsx)(t.li,{children:"Finally, make sure to load all components on start by creating the necessary event edges."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Start the application from AICA Studio, then switch to the 3D view. Drag the frame around and observe how the robot is\ndynamically attracted towards the frame."}),"\n",(0,o.jsx)("div",{style:{display:"flex",justifyContent:"center"},children:(0,o.jsxs)("video",{autoPlay:!0,loop:!0,muted:!0,playsInline:!0,style:{maxWidth:"100%",borderRadius:"8px"},children:[(0,o.jsx)("source",{src:s,type:"video/webm"}),(0,o.jsx)(t.p,{children:"Point Attractor Example."})]})}),"\n",(0,o.jsx)("br",{}),"\n",(0,o.jsxs)(n,{children:[(0,o.jsx)("summary",{children:"Application YAML"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-yaml",children:"schema: 2-0-6\ndependencies:\n  core: v5.0.0\nframes:\n  target:\n    reference_frame: world\n    position:\n      x: 0.372464\n      y: 0.048147\n      z: 0.43\n    orientation:\n      w: -0.000563\n      x: 0.707388\n      y: 0.706825\n      z: 0.000001\non_start:\n  load:\n    - component: signal_point_attractor\n    - hardware: hardware\n    - component: frame_to_signal\ncomponents:\n  frame_to_signal:\n    component: aica_core_components::ros::TfToSignal\n    display_name: Frame to Signal\n    events:\n      transitions:\n        on_load:\n          lifecycle:\n            component: frame_to_signal\n            transition: configure\n        on_configure:\n          lifecycle:\n            component: frame_to_signal\n            transition: activate\n    parameters:\n      frame: target\n    outputs:\n      pose: /frame_to_signal/pose\n  signal_point_attractor:\n    component: aica_core_components::motion::SignalPointAttractor\n    display_name: Signal Point Attractor\n    events:\n      transitions:\n        on_load:\n          lifecycle:\n            component: signal_point_attractor\n            transition: configure\n        on_configure:\n          lifecycle:\n            component: signal_point_attractor\n            transition: activate\n    inputs:\n      state: /hardware/robot_state_broadcaster/cartesian_state\n      attractor: /frame_to_signal/pose\n    outputs:\n      twist: /signal_point_attractor/twist\nhardware:\n  hardware:\n    display_name: Hardware Interface\n    urdf: Generic six-axis robot arm\n    rate: 100\n    events:\n      transitions:\n        on_load:\n          load:\n            - controller: robot_state_broadcaster\n              hardware: hardware\n            - controller: ik_velocity_controller\n              hardware: hardware\n    controllers:\n      robot_state_broadcaster:\n        plugin: aica_core_controllers/RobotStateBroadcaster\n        outputs:\n          cartesian_state: /hardware/robot_state_broadcaster/cartesian_state\n        events:\n          transitions:\n            on_load:\n              switch_controllers:\n                hardware: hardware\n                activate: robot_state_broadcaster\n      ik_velocity_controller:\n        plugin: aica_core_controllers/velocity/IKVelocityController\n        inputs:\n          command: /signal_point_attractor/twist\n        events:\n          transitions:\n            on_load:\n              switch_controllers:\n                hardware: hardware\n                activate: ik_velocity_controller\ngraph:\n  positions:\n    components:\n      frame_to_signal:\n        x: 200\n        y: 600\n      signal_point_attractor:\n        x: 660\n        y: 520\n    hardware:\n      hardware:\n        x: 1120\n        y: -20\n  edges:\n    on_start_on_start_signal_point_attractor_signal_point_attractor:\n      path:\n        - x: 380\n          y: 40\n        - x: 380\n          y: 580\n    on_start_on_start_frame_to_signal_frame_to_signal:\n      path:\n        - x: 140\n          y: 40\n        - x: 140\n          y: 660\n    hardware_hardware_robot_state_broadcaster_cartesian_state_signal_point_attractor_state:\n      path:\n        - x: 620\n          y: 520\n        - x: 620\n          y: 780\n"})})]})]})}function m(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>s});var a=n(6540);const o={},r=a.createContext(o);function i(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);