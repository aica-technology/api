"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5413],{542:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>b,contentTitle:()=>E,default:()=>x,frontMatter:()=>g,metadata:()=>o,toc:()=>f});const o=JSON.parse('{"id":"examples/guides/abb-hardware-interface","title":"ABB manipulators","description":"ABB offers a wide range of industrial articulated manipulators, from compact 6-axis robots for small-part handling and","source":"@site/core_versioned_docs/version-v4/examples/guides/abb-hardware-interface.md","sourceDirName":"examples/guides","slug":"/examples/guides/abb-hardware-interface","permalink":"/core/v4/examples/guides/abb-hardware-interface","draft":false,"unlisted":false,"editUrl":"https://github.com/aica-technology/api/tree/main/core/core_versioned_docs/version-v4/examples/guides/abb-hardware-interface.md","tags":[],"version":"v4","sidebarPosition":10,"frontMatter":{"sidebar_position":10,"title":"ABB manipulators"},"sidebar":"studioSidebar","previous":{"title":"URSim guide","permalink":"/core/v4/examples/guides/ur-sim-guide"},"next":{"title":"Using Isaac Lab as a simulator","permalink":"/core/v4/examples/guides/isaaclab-aica-bridge"}}');var i=t(4848),r=t(8453);t.p;const a=t.p+"assets/images/abb-new-udpuc-device-0404e1a7915769746e026819d794d218.png",s=t.p+"assets/images/abb-controller-configuration-d7b8297e9f967d42c8e8fae771817398.png",l=t.p+"assets/images/abb-additional-options-622deb62e20bbe5c824b1f486eb5c669.png",d=t.p+"assets/images/abb-new-project-826f6f982adba4683111dc12c6ba1968.png",c=t.p+"assets/images/abb-install-addins-4b3f2dbf2ad7cb63900ee78860e1eae5.png",h=t.p+"assets/images/abb-connect-controller-1125729258b952d25303aa6434c2165f.png",u=t.p+"assets/images/abb-firewall-manager-3b29186082d2babbdf74a255b201145b.png",m=t.p+"assets/images/abb-analog-signal-07609b87971046d6c15edc866a03c0fc.png",p=t.p+"assets/images/abb-hi-parameters-3d1fb47bd6636e6286117a024c6e2c7c.png",g={sidebar_position:10,title:"ABB manipulators"},E="ABB manipulators",b={},f=[{value:"General",id:"general",level:2},{value:"Externally Guided Motion",id:"externally-guided-motion",level:3},{value:"Robot Web Services",id:"robot-web-services",level:3},{value:"RAPID",id:"rapid",level:3},{value:"Connecting to a robot",id:"connecting-to-a-robot",level:2},{value:"RobotStudio simulation",id:"robotstudio-simulation",level:3},{value:"Real robot controller",id:"real-robot-controller",level:3},{value:"Network and device configuration",id:"network-and-device-configuration",level:2},{value:"RAPID module",id:"rapid-module",level:2},{value:"Hardware interface",id:"hardware-interface",level:2}];function A(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"abb-manipulators",children:"ABB manipulators"})}),"\n",(0,i.jsx)(n.p,{children:"ABB offers a wide range of industrial articulated manipulators, from compact 6-axis robots for small-part handling and\npayloads of a few kilograms to heavy-duty models capable of lifting up to 800 kg. This guide provides instructions for\nusing ABB robots within the AICA System, focusing on connecting and configuring both simulated environments using\nRobotStudio and real hardware setups."}),"\n",(0,i.jsxs)(n.p,{children:["To use the ABB collection, add ",(0,i.jsx)(n.code,{children:"collections/abb"})," ",(0,i.jsx)(n.strong,{children:"v1.0.0 or higher"})," to your configuration in AICA Launcher, currently\nsupporting the following robot models out of the box:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"IRB 1010"}),"\n",(0,i.jsx)(n.li,{children:"GoFa CRB 15000, 12 Kg"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"general",children:"General"}),"\n",(0,i.jsxs)(n.p,{children:["This guide and the provided drivers are designed for ABB robots connected to OmniCore controllers, whether in simulation\nor with real hardware. Ensure your setup uses ",(0,i.jsx)(n.strong,{children:"RobotWare for OmniCore"})," for full compatibility with the instructions\nand features described below."]}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:"This collection supports RobotWare versions 7.X and above. For older versions, contact the AICA support team."})}),"\n",(0,i.jsx)(n.h3,{id:"externally-guided-motion",children:"Externally Guided Motion"}),"\n",(0,i.jsxs)(n.p,{children:["ABB permits remote control of its manipulator range using the Externally Guided Motion (EGM) feature. EGM\nprovides external devices with the ability to send commands and control ABB robotic arms, using Google's Protocol\nBuffers (Protobuf) serialization library to transport information through UDP sockets. For more information, check out\nthe\n",(0,i.jsx)(n.a,{href:"https://library.e.abb.com/public/344f15f0f43341eb944fe35279d9fa2e/3HAC073319+AM+Externally+Guided+Motion+RW6-en.pdf?x-sign=WlxgV7Vao27KV3d3hlsfaoykgctYqoA0F98ch89S%2FPEaGwQg47ou%2FioylQtzvLaV",children:"official product documentation"}),"."]}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:"EGM is an optional add-in and has to be purchased separately."})}),"\n",(0,i.jsx)(n.h3,{id:"robot-web-services",children:"Robot Web Services"}),"\n",(0,i.jsxs)(n.p,{children:["The second ABB feature that AICA System utilizes to connect to the robot is Robot Web Services (RWS). RWS is a platform\nthat enables developers to create applications that interact with the robot controller, using RESTful APIs that leverage\nthe HTTPS protocol. The hardware interface uses RWS for auxiliary functionality, such as starting/stopping the program\nand the motors, and setting IOs. Setting up RWS on the simulator and on the actual robot requires slightly different\nsteps, which will be explained in the following sections. More information can be found on the\n",(0,i.jsx)(n.a,{href:"https://developercenter.robotstudio.com/api/RWS",children:"product reference page"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"rapid",children:"RAPID"}),"\n",(0,i.jsxs)(n.p,{children:["RAPID is the programming language of ABB robots. Users can utilize RAPID to set up and execute their workflows and\nprocesses. This is enabled by user-defined libraries called ",(0,i.jsx)(n.em,{children:"Modules"}),", that contain variables and functions or\nprocesses (",(0,i.jsx)(n.em,{children:"PROCs"}),"). Modules can then be loaded in controller ",(0,i.jsx)(n.em,{children:"Tasks"}),", and called as required."]}),"\n",(0,i.jsx)(n.h2,{id:"connecting-to-a-robot",children:"Connecting to a robot"}),"\n",(0,i.jsx)(n.p,{children:"The hardware interface provided by the ABB collection can be used to control either a simulated or a real robot. The\nfollowing sections provide the necessary steps to do both."}),"\n",(0,i.jsx)(n.h3,{id:"robotstudio-simulation",children:"RobotStudio simulation"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://new.abb.com/products/robotics/software-and-digital/robotstudio",children:"RobotStudio"})," is the official ABB offline\nprogramming and simulation tool for robotics applications. It allows to run virtual controllers that mimic the behavior\nof the real robot, ensuring seamless transition between simulation and hardware. It can also be used to configure\nseveral aspects of the real controller."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"The RobotStudio software suite is available only for Windows, so you may need to set it up on a secondary device or a\nvirtual machine."})}),"\n",(0,i.jsx)(n.p,{children:"Setting up a virtual workstation and controller can be achieved by following the next steps:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["In RobotStudio, navigate to the ",(0,i.jsx)(n.strong,{children:"Add-Ins"})," tab and go to ",(0,i.jsx)(n.strong,{children:"Gallery"}),". There is a list of all available robot models\nand RobotWare versions, the internal controller software. To ensure consistency between simulation and reality, make\nsure to install the versions matching the real robot controller, if one is available.","\n",(0,i.jsx)("div",{class:"text--center",children:(0,i.jsx)("img",{src:c,alt:"Install necessary addins in RobotStudio."})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Go back to to ",(0,i.jsx)(n.strong,{children:"File > New > Project"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"Select to create a new controller and define the robot model and variant, as well as the RobotWare version."}),"\n",(0,i.jsxs)(n.li,{children:["Make sure to activate the ",(0,i.jsx)(n.strong,{children:"Customize Options"})," button. This is required to add EGM in a next step.","\n",(0,i.jsx)("div",{class:"text--center",children:(0,i.jsx)("img",{src:d,alt:"Create a new RobotStudio project."})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Select ",(0,i.jsx)(n.strong,{children:"Create"})," to create the new project."]}),"\n",(0,i.jsxs)(n.li,{children:["In the window that pops up, in the ",(0,i.jsx)(n.strong,{children:"Options"})," tab, look for ",(0,i.jsx)(n.strong,{children:"EGM"})," and ",(0,i.jsx)(n.strong,{children:"RobotStudio Connect"})," and add them in the\ncontroller. Then select ",(0,i.jsx)(n.strong,{children:"Apply and Reset"})," to finalize.","\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"3119-1 RobotStudio Connect"})," add-in is required to connect a controller to RobotStudio over a public network.\nFor more information, see the RobotStudio instruction manual."]})}),"\n",(0,i.jsx)("div",{class:"text--center",children:(0,i.jsx)("img",{src:l,alt:"Additional options in the RobotStudio project."})}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"Disable the Windows firewall on the network where the PC running AICA Core is connected to."}),"\n",(0,i.jsxs)(n.li,{children:["Finally, the PC running AICA Core has to be whitelisted to communicate with RobotStudio. As explained\n",(0,i.jsx)(n.a,{href:"https://forums.robotstudio.com/discussion/12082/using-robotwebservices-to-access-a-remote-virtual-controller",children:"here"}),",\ncreate a file called ",(0,i.jsx)(n.code,{children:"vcconf.xml"})," under ",(0,i.jsx)(n.code,{children:"C:/Users/<user>/AppData/Roaming/ABB Industrial IT/Robotics IT/RobVC"})," with\nthe content below. Replace ",(0,i.jsx)(n.code,{children:"<user>"})," in the path above with your Windows user and the IP address in the snippet below with\nthe IP of the PC running AICA Core (in this example 192.168.137.100).","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",metastring:'title="vcconf.xml"',children:'<?xml version="1.0" encoding="UTF-8"?>\n<VCConfiguration><RemoteVCConfiguration PublicationEnabled="true"/><hosts><host ip="192.168.137.100"/></hosts></VCConfiguration>\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"real-robot-controller",children:"Real robot controller"}),"\n",(0,i.jsxs)(n.p,{children:["RobotStudio can be used to configure the address of the external control device. Navigate to the Controller tab and\nselect ",(0,i.jsx)(n.strong,{children:"Add Controller > Connect to Controller"}),". This will allow to detect and connect to the running controller in\nOmniCore, provided of course that the devices are on the same network."]}),"\n",(0,i.jsx)("div",{class:"text--center",children:(0,i.jsx)("img",{src:h,alt:"Connect to the robot controller."})}),"\n",(0,i.jsx)(n.h2,{id:"network-and-device-configuration",children:"Network and device configuration"}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Modifications in the real robot controller require write access. To get it, click on ",(0,i.jsx)(n.strong,{children:"Request Write Access"})," and\nconfirm on the pendant's screen. To save these modifications, the controller has to be restarted. While this takes\nseconds in simulation, the restart procedure in the real robot might take a few minutes, so make all necessary changes,\nand then restart."]})}),"\n",(0,i.jsx)(n.p,{children:"After connecting to the robot, the controller should be configured to accept commands from an external device."}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Navigate to the Controller tab > Configuration > Communication > UDP Unicast Device, and add a new UDPUC device (or\nmodify the existing one), configured as shown below. This is the PC running AICA Core, the external control device,\nso the address should be set accordingly.","\n",(0,i.jsx)("div",{class:"text--center",children:(0,i.jsx)("img",{src:s,alt:"Controller configuration settings."})}),"\n",(0,i.jsx)("div",{class:"text--center",children:(0,i.jsx)("img",{src:a,alt:"Add a new UDPUC device."})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Navigate to the Controller tab > Configuration > Communication > Firewall Manager, and make sure that UDPUC and\nRobotWebServices are enabled in the network that is being used.","\n",(0,i.jsx)("div",{class:"text--center",children:(0,i.jsx)("img",{src:u,alt:"Firewall manager options."})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Navigate to the Controller tab > Configuration > I/O System > Signal, and add a new signal as shown below.","\n",(0,i.jsx)("div",{class:"text--center",children:(0,i.jsx)("img",{src:m,alt:"Add analog signal.",style:{width:"536px"}})}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"Finally, for the changes to take effect, restart the controller."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"rapid-module",children:"RAPID module"}),"\n",(0,i.jsx)(n.p,{children:"The ABB hardware interface provided by AICA needs a matching RAPID module running on the robot to allow external control\nthrough EGM. Place the module below in the controller's home directory and upload it to the current task."}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:"The setup steps above are required for the module to run properly, follow them closely."})}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"AICA_EGM.modx"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'MODULE AICA_EGM\n    LOCAL RECORD EGMSettings\n        ! UdpUc device name\n        string uc_device;\n        ! Time-out for communication with the external UdpUC device in seconds\n        num comm_timeout;\n        ! The convergence criteria datais used to decide if the robot has reached the ordered joint positions\n        num cond_min_max;\n        ! Maximum admitted joint speed change in degrees/second\n        num max_speed_deviation;\n        ! The time in seconds that the convergence criteria defined in EGMActJoint has to\n        !   be fulfilled before the target point is considered to be reached\n        num cond_time;\n        ! Defines in seconds how fast the movement is started\n        num ramp_in_time;\n        ! Position correction gain. A value between 0 and 1\n        num pos_corr_gain;\n    ENDRECORD\n    LOCAL CONST string CONTEXT_MAIN:="[Main]: ";\n    LOCAL CONST string CONTEXT_EGM:="[EGM]: ";\n    LOCAL CONST num STATE_IDLE:=0;\n    LOCAL CONST num STATE_INITIALIZE:=1;\n    LOCAL CONST num STATE_RUN_EGM:=2;\n    LOCAL VAR num current_state;\n    LOCAL VAR errnum CHANGE_STATE:=-1;\n    LOCAL VAR num idle_counter:=0;\n    LOCAL VAR intnum intnum_start_egm;\n    LOCAL VAR intnum intnum_stop_egm;\n    LOCAL VAR intnum intnum_restart_egm;\n    ! EGM settings\n    LOCAL CONST string DEFAULT_UC_DEVICE:="UC_DEVICE";\n    LOCAL VAR egmident egm_id;\n    LOCAL VAR EGMSettings settings;\n    LOCAL VAR egm_minmax minmax_condition;\n    LOCAL VAR bool egm_setup;\n    LOCAL VAR jointtarget current_j;\n    PROC main()\n        TPErase;\n        initialize;\n        printInfoMessage 0, CONTEXT_MAIN, "Starting StateMachine loop";\n        WHILE TRUE DO\n            TEST current_state\n                CASE STATE_RUN_EGM:\n                    runEGM;\n                DEFAULT:\n                    runIdle;\n            ENDTEST\n            WaitTime 0.01;\n        ENDWHILE\n    ERROR(CHANGE_STATE)\n        idle_counter:=0;\n        TRYNEXT;\n    ENDPROC\n    LOCAL PROC initialize()\n        IDisable;\n        BookErrNo CHANGE_STATE;\n        IDelete intnum_stop_egm;\n        CONNECT intnum_stop_egm WITH handleStopEGM;\n        ISignalAI AICA_EGM_STATE, AIO_BELOW_LOW, 1.5, 0.5, 0, intnum_stop_egm;\n        IDelete intnum_start_egm;\n        CONNECT intnum_start_egm WITH handleStartEGM;\n        ISignalAI AICA_EGM_STATE, AIO_BETWEEN, 1.5, 0.5, 0, intnum_start_egm;\n        IDelete intnum_restart_egm;\n        CONNECT intnum_restart_egm WITH handleRestartEGM;\n        ISignalAI AICA_EGM_STATE, AIO_BETWEEN, 2.5, 1.5, 0, intnum_restart_egm;\n        current_state:=STATE_IDLE;\n        EGMReset egm_id;\n        EGMGetId egm_id;\n        egm_setup:=FALSE;\n        settings.uc_device:=DEFAULT_UC_DEVICE;\n        settings.comm_timeout:=1;\n        settings.cond_min_max:=0.1;\n        settings.max_speed_deviation:=120; ! lowest axis speed on GoFa 12kg\n        settings.cond_time:=5;\n        settings.ramp_in_time:=1;\n        settings.pos_corr_gain:=1;\n        IEnable;\n    ENDPROC\n    LOCAL PROC runEGM()\n        IF NOT egm_setup THEN\n            printInfoMessage 2, CONTEXT_EGM, "Wait until zero speed";\n            WaitRob\\ZeroSpeed;\n            minmax_condition.min:=-Abs(settings.cond_min_max);\n            minmax_condition.max:=Abs(settings.cond_min_max);\n            EGMSetupUC ROB_ID, egm_id, "default", settings.uc_device \\Joint \\CommTimeout:=settings.comm_timeout;\n            EGMActJoint egm_id\n                        \\J1:=minmax_condition\n                        \\J2:=minmax_condition\n                        \\J3:=minmax_condition\n                        \\J4:=minmax_condition\n                        \\J5:=minmax_condition\n                        \\J6:=minmax_condition\n                        \\MaxSpeedDeviation:=settings.max_speed_deviation;\n            printInfoMessage 2, CONTEXT_EGM, "EGM set up";\n            egm_setup:=TRUE;\n        ENDIF\n        IF egm_setup AND EGMGetState(egm_id)=EGM_STATE_CONNECTED THEN\n            printInfoMessage 2, CONTEXT_EGM, "Starting EGM";\n            saturateValue settings.pos_corr_gain, 0, 1;\n            EGMRunJoint egm_id,\n                        EGM_STOP_HOLD\n                        \\J1\\J2\\J3\\J4\\J5\\J6\n                        \\CondTime:=settings.cond_time\n                        \\RampInTime:=settings.ramp_in_time\n                        \\PosCorrGain:=settings.pos_corr_gain;\n            printInfoMessage 2, CONTEXT_EGM, "EGMRunJoint terminated";\n        ENDIF\n    ERROR\n        IF ERRNO=ERR_UDPUC_COMM THEN\n            printInfoMessage 2, CONTEXT_EGM, "Communication timeout";\n            egm_setup:=FALSE;\n            TRYNEXT;\n        ENDIF\n    ENDPROC\n    LOCAL PROC runIdle()\n        IF idle_counter MOD 1000 = 0 THEN\n            printInfoMessage 0, CONTEXT_MAIN, "Idling...";\n            idle_counter:=0;\n        ENDIF\n        Incr idle_counter;\n    ERROR\n        RAISE;\n    ENDPROC\n    LOCAL TRAP handleStopEGM\n        printInfoMessage 0, CONTEXT_MAIN, "Handling EGM stop";\n        IF current_state=STATE_RUN_EGM AND EGMGetState(egm_id)=EGM_STATE_RUNNING THEN\n            EGMStop egm_id,EGM_STOP_HOLD;\n            current_state:=STATE_IDLE;\n            RAISE CHANGE_STATE;\n        ENDIF\n        printInfoMessage 0, CONTEXT_MAIN, "EGM stop is not possible";\n    ERROR (CHANGE_STATE)\n        RAISE CHANGE_STATE;\n    ENDTRAP\n    LOCAL TRAP handleStartEGM\n        printInfoMessage 0, CONTEXT_MAIN, "Handling EGM start";\n        IF current_state=STATE_IDLE THEN\n            current_state:=STATE_RUN_EGM;\n            RAISE CHANGE_STATE;\n        ENDIF\n        printInfoMessage 0, CONTEXT_MAIN, "EGM start is not possible";\n    ERROR (CHANGE_STATE)\n        RAISE CHANGE_STATE;\n    ENDTRAP\n    LOCAL TRAP handleRestartEGM\n        printInfoMessage 0, CONTEXT_MAIN, "Handling EGM restart";\n        IF current_state=STATE_RUN_EGM AND EGMGetState(egm_id)=EGM_STATE_RUNNING THEN\n            EGMStop egm_id,EGM_STOP_HOLD;\n            RAISE CHANGE_STATE;\n        ENDIF\n        printInfoMessage 0, CONTEXT_MAIN, "EGM restart is not possible";\n    ERROR (CHANGE_STATE)\n        RAISE CHANGE_STATE;\n    ENDTRAP\n    PROC saturateValue(VAR num value, num minimum, num maximum)\n        IF value < minimum THEN\n            value := minimum;\n        ELSEIF value > maximum THEN\n            value := maximum;\n        ENDIF\n    ENDPROC\n    LOCAL PROC printInfoMessage(num indention_level, string context, string message)\n        VAR string temp_indention:="";\n        IF(indention_level > 0) THEN\n            FOR i FROM 0 TO indention_level-1 DO\n                temp_indention:=temp_indention + " ";\n            ENDFOR\n        ENDIF\n        TPWrite temp_indention + context + message;\n    ENDPROC\n    LOCAL PROC printEGMState()\n        TEST EGMGetState(egm_id)\n        CASE EGM_STATE_DISCONNECTED:\n            printInfoMessage 2, CONTEXT_EGM, "DISCONNECTED";\n        CASE EGM_STATE_CONNECTED:\n            printInfoMessage 2, CONTEXT_EGM, "CONNECTED";\n        CASE EGM_STATE_RUNNING:\n            printInfoMessage 2, CONTEXT_EGM, "RUNNING";\n        DEFAULT:\n            printInfoMessage 2, CONTEXT_EGM, "UNKNOWN";\n        ENDTEST\n    ENDPROC\nENDMODULE\n'})})]}),"\n",(0,i.jsx)(n.h2,{id:"hardware-interface",children:"Hardware interface"}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"For optimal performance, set the hardware interface rate to 250 Hertz. This matches ABB's recommended stable limit for\nUDP data exchange."})}),"\n",(0,i.jsx)(n.p,{children:"Returning to AICA Studio and the hardware interface, it is now possible to define the parameters and connect to the\nrobot. The majority of the hardware interface parameters enable connection to EGM and RWS:"}),"\n",(0,i.jsx)("div",{class:"text--center",children:(0,i.jsx)("img",{src:p,alt:"ABB Hardware interface parameters"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["RWS IP & port: the address and port of the RWS server, e.g. the address of the real robot or the RobotStudio device","\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["OmniCore controllers and RobotWare 7.x versions by default listen on HTTPS and port 80 for RobotStudio and 443 for the\nreal robot. If necessary, the port numbers can be modified by following the instructions in this\n",(0,i.jsx)(n.a,{href:"https://forums.robotstudio.com/discussion/12177/how-to-change-the-listening-port-of-the-virtual-controller-robotware-6-x-and-7-x",children:"forum post"}),"."]})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["EGM port: the port of the EGM server, e.g. the ",(0,i.jsx)(n.em,{children:"Remote Port Number"})," of the UDPUC device defined in RobotStudio above"]}),"\n",(0,i.jsx)(n.li,{children:"Connection timeout: the amount of time the hardware interface tries to connect to the RWS and EGM servers before\nreporting an error"}),"\n",(0,i.jsxs)(n.li,{children:["Controller Task and Main Module name: Depends on the controller configuration and usually defaults to ",(0,i.jsx)(n.code,{children:"T_ROB1"})," and\n",(0,i.jsx)(n.code,{children:"AICA_EGM"}),", respectively."]}),"\n",(0,i.jsx)(n.li,{children:"Uc Device: The name of the UDPUC device configured above."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Before starting an application with an ABB hardware interface in AICA Studio, the motors and RAPID program on the robot\nmust be started manually through the teach pendant or RobotStudio. After that, running the application will connect to\nthe robot and get information about the mechanical setup of the robot being used."})]})}function x(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(A,{...e})}):A(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var o=t(6540);const i={},r=o.createContext(i);function a(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);