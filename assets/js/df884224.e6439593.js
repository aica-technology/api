"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4693],{5559:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"concepts/building-blocks/controllers/ik","title":"Inverse Kinematics","description":"IK controllers operate in task space, allowing users to specify desired end-effector poses or motions, while the","source":"@site/docs/concepts/building-blocks/controllers/ik.md","sourceDirName":"concepts/building-blocks/controllers","slug":"/concepts/building-blocks/controllers/ik","permalink":"/docs/concepts/building-blocks/controllers/ik","draft":false,"unlisted":false,"editUrl":"https://github.com/aica-technology/api/tree/main/docs/docs/concepts/building-blocks/controllers/ik.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Inverse Kinematics"},"sidebar":"learnSidebar","previous":{"title":"GPIO","permalink":"/docs/concepts/building-blocks/controllers/gpio"},"next":{"title":"Joint Trajectory","permalink":"/docs/concepts/building-blocks/controllers/jtc"}}');var t=i(4848),s=i(8453);const r={sidebar_position:2,title:"Inverse Kinematics"},a="Inverse Kinematics (IK) controllers",c={},l=[{value:"Inverse kinematics position controller",id:"inverse-kinematics-position-controller",level:2},{value:"Key characteristics and advantages",id:"key-characteristics-and-advantages",level:3},{value:"Typical use cases",id:"typical-use-cases",level:3},{value:"Inverse kinematics velocity controller",id:"inverse-kinematics-velocity-controller",level:2},{value:"Key characteristics and advantages",id:"key-characteristics-and-advantages-1",level:3},{value:"Typical use cases",id:"typical-use-cases-1",level:3},{value:"Position vs velocity IK control",id:"position-vs-velocity-ik-control",level:2},{value:"Using it in AICA Core",id:"using-it-in-aica-core",level:2}];function d(e){const n={a:"a",admonition:"admonition",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"inverse-kinematics-ik-controllers",children:"Inverse Kinematics (IK) controllers"})}),"\n",(0,t.jsxs)(n.p,{children:["IK controllers operate in ",(0,t.jsx)(n.strong,{children:"task space"}),", allowing users to specify desired end-effector poses or motions, while the\ncontroller computes the corresponding joint commands internally. This enables intuitive Cartesian control and\ncoordinated multi-joint motion without requiring direct manipulation of individual joints."]}),"\n",(0,t.jsxs)(n.p,{children:["Depending on how the desired motion is expressed, IK controllers can be broadly categorized into ",(0,t.jsx)(n.strong,{children:"position-based"}),"\nand ",(0,t.jsx)(n.strong,{children:"velocity-based"})," controllers."]}),"\n",(0,t.jsx)(n.h2,{id:"inverse-kinematics-position-controller",children:"Inverse kinematics position controller"}),"\n",(0,t.jsxs)(n.p,{children:["An ",(0,t.jsx)(n.strong,{children:"IK Position Controller"})," is designed to drive a robot toward a desired ",(0,t.jsx)(n.strong,{children:"Cartesian pose"})," (position and\norientation) of a controlled frame. Instead of commanding joint positions directly, the user specifies a target pose in\ntask space, and the controller computes the joint configuration that best realizes this pose."]}),"\n",(0,t.jsxs)(n.p,{children:["The controller continuously evaluates the Cartesian pose error and updates the joint commands accordingly, typically\nthrough an iterative process. This makes IK position control suitable for goal-driven tasks where the objective is to\n",(0,t.jsx)(n.strong,{children:"reach and maintain"})," a specific end-effector pose."]}),"\n",(0,t.jsx)(n.h3,{id:"key-characteristics-and-advantages",children:"Key characteristics and advantages"}),"\n",(0,t.jsx)(n.p,{children:"Compared to joint-space position controllers, an IK position controller offers several advantages:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Direct Cartesian goal specification:"}),'\nTargets are expressed as end-effector poses (e.g., "move the tool to this pose"), which is often more intuitive than\nspecifying joint angles.']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Automatic joint coordination:"}),"\nAll joints are adjusted together to achieve the desired pose, ensuring consistent and coordinated motion."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reactive behavior:"}),"\nThe controller continuously recomputes joint commands, allowing it to respond to disturbances or changes in the\ntarget pose."]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsxs)(n.p,{children:["In reactive or high-rate scenarios, IK position control can be difficult to apply. The command signal needs to be\ncrafted carefully to ensure continuity and avoid big step changes. Position servoing is demanding for real hardware and\nusually comes with strict constraints from the manufacturer. See more information in\n",(0,t.jsx)(n.a,{href:"/docs/concepts/building-blocks/controllers/ik#position-vs-velocity-ik-control",children:"Position vs velocity IK control"}),"."]})}),"\n",(0,t.jsx)(n.h3,{id:"typical-use-cases",children:"Typical use cases"}),"\n",(0,t.jsx)(n.p,{children:"IK position control is well suited for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Reaching or holding a Cartesian pose"}),"\n",(0,t.jsx)(n.li,{children:"Pose-based alignment or docking"}),"\n",(0,t.jsx)(n.li,{children:"Interactive goal specification in Cartesian space"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"inverse-kinematics-velocity-controller",children:"Inverse kinematics velocity controller"}),"\n",(0,t.jsxs)(n.p,{children:["An ",(0,t.jsx)(n.strong,{children:"IK Velocity Controller"})," is designed to control a robot's motion by commanding\n",(0,t.jsx)(n.strong,{children:"joint velocities"})," such that a desired ",(0,t.jsx)(n.strong,{children:"task-space velocity"})," is achieved. Instead of following a predefined\ntime-parameterized trajectory, the controller continuously computes how fast each joint should move\n",(0,t.jsx)(n.em,{children:"at the current control step"})," so that the end effector (or any controlled frame) moves with a specified linear and/or\nangular velocity in Cartesian space."]}),"\n",(0,t.jsxs)(n.p,{children:["This approach is fundamentally ",(0,t.jsx)(n.strong,{children:"reactive and continuous"}),", making it well suited for online control, teleoperation, and\ninteraction-driven tasks."]}),"\n",(0,t.jsx)(n.h3,{id:"key-characteristics-and-advantages-1",children:"Key characteristics and advantages"}),"\n",(0,t.jsx)(n.p,{children:"Compared to joint-level velocity or position controllers, an IK velocity controller offers several key advantages:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Task-space control:"}),'\nMotion is specified directly in Cartesian space (e.g., "move the end effector forward at 5 cm/s"), which is often more\nintuitive and meaningful than joint commands.']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Continuous motion generation:"}),"\nCommands are generated at each control cycle, allowing smooth adaptation to changes in goals, sensor feedback, or\nexternal disturbances."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"High responsiveness:"}),"\nSince there is no fixed trajectory to follow, the controller can immediately react to new commands or constraints."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Coordinated joint motion:"}),"\nJoint velocities are computed jointly to satisfy the task-space objective, ensuring coherent motion across all joints\nin the kinematic chain."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"typical-use-cases-1",children:"Typical use cases"}),"\n",(0,t.jsx)(n.p,{children:"IK velocity control is particularly well suited for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Cartesian and visual servoing"}),"\n",(0,t.jsx)(n.li,{children:"Teleoperation and joystick-based control"}),"\n",(0,t.jsx)(n.li,{children:"Interaction and compliance tasks"}),"\n",(0,t.jsx)(n.li,{children:"Online motion correction or refinement"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"position-vs-velocity-ik-control",children:"Position vs velocity IK control"}),"\n",(0,t.jsx)(n.p,{children:"In summary:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"IK position controllers"})," are goal-oriented: they answer ",(0,t.jsx)(n.em,{children:'"Where should the end effector be?"'})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"IK velocity controllers"})," are motion-oriented: they answer ",(0,t.jsx)(n.em,{children:'"How should the end effector move right now?"'})]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Both approaches provide intuitive Cartesian control, but they are suited to different classes of applications depending\non whether the task is pose-driven or continuously evolving."}),"\n",(0,t.jsxs)(n.p,{children:["In practice, ",(0,t.jsx)(n.strong,{children:"IK position controllers are generally harder to use in reactive and real-time scenarios"}),". Computing a\nvalid inverse kinematics solution for a full Cartesian pose can fail due to singularities, joint limits, or conflicting\nconstraints, especially when targets change frequently or abruptly. This makes position-based IK less robust for\nhigh-rate, online control."]}),"\n",(0,t.jsxs)(n.p,{children:["On the other hand, it is mathematically less demanding and more robust to compute the inverse kinematics solution for a\ndesired velocity. For this reason, ",(0,t.jsx)(n.strong,{children:"IK velocity control is often preferred in reactive applications"}),". A common pattern\nis to combine IK velocity controllers with motion generators that produce desired Cartesian twists (see our\n",(0,t.jsx)(n.a,{href:"/docs/concepts/robotics-concepts/motion-generation",children:"Motion generation"})," page). This allows pose-driven behavior\nto be expressed as smooth, continuous velocity commands, while retaining the robustness, responsiveness, and stability\nproperties of velocity-based IK control."]}),"\n",(0,t.jsx)(n.h2,{id:"using-it-in-aica-core",children:"Using it in AICA Core"}),"\n",(0,t.jsxs)(n.p,{children:["Both an IK position and velocity controller are included in AICA Core by default. They can be used via a\n",(0,t.jsx)(n.strong,{children:"Cartesian pose"})," and ",(0,t.jsx)(n.strong,{children:"Cartesian twist"})," signal, respectively, that indicates the desired state. Additional parameters\ncan be modified to limit the Cartesian position or velocity."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var o=i(6540);const t={},s=o.createContext(t);function r(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);