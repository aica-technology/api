"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2131],{8314:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"concepts/building-blocks/signals","title":"Signals","description":"In the AICA System, signals are designed to exchange continuous data between components and controllers in a running","source":"@site/docs/concepts/building-blocks/signals.md","sourceDirName":"concepts/building-blocks","slug":"/concepts/building-blocks/signals","permalink":"/docs/concepts/building-blocks/signals","draft":false,"unlisted":false,"editUrl":"https://github.com/aica-technology/api/tree/main/docs/docs/concepts/building-blocks/signals.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Signals"},"sidebar":"learnSidebar","previous":{"title":"Application building blocks","permalink":"/docs/category/application-building-blocks"},"next":{"title":"Events","permalink":"/docs/concepts/building-blocks/events"}}');var t=s(4848),a=s(8453);const o={sidebar_position:1,title:"Signals"},l="Signals",r={},c=[{value:"Basic signal types",id:"basic-signal-types",level:2},{value:"State signals",id:"state-signals",level:2},{value:"Custom messages",id:"custom-messages",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"signals",children:"Signals"})}),"\n",(0,t.jsx)(n.p,{children:"In the AICA System, signals are designed to exchange continuous data between components and controllers in a running\napplication. They are an abstraction of ROS 2 topics that are assumed to exchange data at a regular, periodic frequency.\nThis makes them well-suited for use with signal processing components and controllers."}),"\n",(0,t.jsx)(n.p,{children:'ROS 2 topics are messages sent from publishers to subscribers under a specific namespace (the message "topic")\nusing some predefined message format (the message "type"). As a result, topics enable ROS nodes to communicate in many\ndifferent network topologies and message formats.'}),"\n",(0,t.jsx)(n.p,{children:"Often, the message topic and message type is hardcoded within the implementation of a ROS node. This can make it\ndifficult to rearrange the network topology of ROS nodes without modifying and recompiling the node implementation\nitself."}),"\n",(0,t.jsx)(n.p,{children:"Signals then are ROS 2 publishers and subscribers with dynamically assigned topics and standardized message types.\nThis makes it easy to reconfigure the signal connections between different components and controllers in the application\ngraph without modifying or recompiling any source code. By using standard message types, the signal compatibility\nbetween components and controllers is also simplified."}),"\n",(0,t.jsx)(n.p,{children:"Additionally, ROS 2 messages are data packets, not data objects. Parsing data from a message, manipulating it and\nwriting it back into a message can involve a fair amount of boilerplate code."}),"\n",(0,t.jsx)(n.p,{children:"When developing an AICA component, signals are automatically converted to and from the corresponding data object."}),"\n",(0,t.jsx)(n.h2,{id:"basic-signal-types",children:"Basic signal types"}),"\n",(0,t.jsx)(n.p,{children:"The following standard message types are provided for signals."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Boolean (true / false)"}),"\n",(0,t.jsx)(n.li,{children:"Integer (whole numbers)"}),"\n",(0,t.jsx)(n.li,{children:"Double (floating point numbers)"}),"\n",(0,t.jsx)(n.li,{children:"Vector (array of floating point numbers)"}),"\n",(0,t.jsx)(n.li,{children:"String (plain text)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"state-signals",children:"State signals"}),"\n",(0,t.jsxs)(n.p,{children:["In robot control applications, the ",(0,t.jsx)(n.em,{children:"state"})," of a robot or other objects is highly important."]}),"\n",(0,t.jsx)(n.p,{children:"In robotics and control, one of the most useful data types is the state of an object, i.e. its spatial properties.\nThe joint angles of a robot arm, the 3D position and velocity of a flying drone, or the measurement of an accelerometer\nor force-torque sensor are all examples of instantaneous state variables."}),"\n",(0,t.jsx)(n.p,{children:"AICA signals make it easy for components and controllers to exchange Cartesian and joint state variables in an\ninternally consistent way. For component developers, state signals are automatically converted into smart data classes\nthat provide useful functions for conversions, transformations and other manipulations."}),"\n",(0,t.jsx)(n.p,{children:"The following state variables can be exchanged as signals:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Joint state","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Positions"}),"\n",(0,t.jsx)(n.li,{children:"Velocities"}),"\n",(0,t.jsx)(n.li,{children:"Accelerations"}),"\n",(0,t.jsx)(n.li,{children:"Torques"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Cartesian state","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Pose","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Position"}),"\n",(0,t.jsx)(n.li,{children:"Orientation"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Twist","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Linear velocity"}),"\n",(0,t.jsx)(n.li,{children:"Angular velocity"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Acceleration","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Linear acceleration"}),"\n",(0,t.jsx)(n.li,{children:"Angular acceleration"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Wrench","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Force"}),"\n",(0,t.jsx)(n.li,{children:"Torque"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["AICA state signals are built on the\nopen-source ",(0,t.jsx)(n.a,{href:"https://aica-technology.github.io/control-libraries/versions/v7.1.0/md__github_workspace_source_state_representation__r_e_a_d_m_e.html",children:(0,t.jsx)(n.code,{children:"state_representation"})}),"\nlibrary for Cartesian and joint state classes in C++ and Python."]})}),"\n",(0,t.jsx)(n.h2,{id:"custom-messages",children:"Custom messages"}),"\n",(0,t.jsx)(n.p,{children:"The standard primitive and state message types are generally enough to cover the majority of messaging needs in\nan AICA application. Having a reduced message definition set is important to maximizing the modularity and compatibility\nof components. When components are connected by a signal in an application graph, the application interpreter will try\nto assert that the signals have a matching type."}),"\n",(0,t.jsxs)(n.p,{children:["However, any ROS 2 message can be implemented as a signal using the ",(0,t.jsx)(n.code,{children:"custom"})," signal type. As long as the custom type\nbetween two connected components has the same name, the application will be valid."]}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["The AICA component library\n",(0,t.jsx)(n.a,{href:"/core/examples/core-components/signal-interoperability",children:"includes signal translator components"})," for commonly used ROS\nmessages (namely ",(0,t.jsx)(n.code,{children:"sensor_msgs"})," and ",(0,t.jsx)(n.code,{children:"geometry_msgs"}),") for AICA components to communicate with traditional ROS nodes in an\nexternal process."]})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var i=s(6540);const t={},a=i.createContext(t);function o(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);